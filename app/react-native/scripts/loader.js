const path = require('path');
const fs = require('fs');
const glob = require('glob');
const prettier = require('prettier');

const cwd = process.cwd();

const previewImports = `
  import { decorators, parameters } from './preview';

  if (decorators) {
    decorators.forEach((decorator) => addDecorator(decorator));
  }

  if (parameters) {
    addParameters(parameters);
  }
`;

function normalizeExcludePaths(paths) {
  // automatically convert a string to an array of a single string
  if (typeof paths === 'string') {
    return [paths];
  }

  // ensure the paths is an array and if any items exists, they are strings
  if (Array.isArray(paths) && paths.every((p) => typeof p === 'string')) {
    return paths;
  }

  // when the paths aren't a string or an (empty) array of strings, return
  return undefined;
}

function requireUncached(module) {
  delete require.cache[require.resolve(module)];
  return require(module);
}

function getMain({ configPath }) {
  const mainPath = path.resolve(cwd, configPath, 'main.js');
  return requireUncached(mainPath);
}

function getPreviewExists({ configPath }) {
  const supportedExtensions = ['js', 'jsx', 'ts', 'tsx'];

  for (const ext of supportedExtensions) {
    const previewPath = path.resolve(cwd, configPath, `preview.${ext}`);

    if (fs.existsSync(previewPath)) {
      return true;
    }
  }

  return false;
}

function writeRequires({ configPath, absolute = false }) {
  const storybookRequiresLocation = path.resolve(cwd, configPath, 'storybook.requires.js');

  const main = getMain({ configPath });
  const reactNativeOptions = main.reactNativeOptions;
  const excludePaths = reactNativeOptions && reactNativeOptions.excludePaths;
  const normalizedExcludePaths = normalizeExcludePaths(excludePaths);

  const storyPaths = main.stories.reduce((acc, storyGlob) => {
    const paths = glob.sync(storyGlob, {
      cwd: path.resolve(cwd, configPath),
      absolute,
      // default to always ignore (exclude) anything in node_modules
      ignore: normalizedExcludePaths !== undefined ? normalizedExcludePaths : ['**/node_modules'],
    });
    return [...acc, ...paths];
  }, []);

  fs.writeFileSync(storybookRequiresLocation, '');

  const previewExists = getPreviewExists({ configPath });

  let previewJs = previewExists ? previewImports : '';

  const storyRequires = storyPaths.map((storyPath) => `require("${storyPath}")`).join(',');
  const path_array_str = `[${storyRequires}]`;

  const registerAddons = main.addons.map((addon) => `import "${addon}/register";`).join('\n');
  let enhancersImport = '';
  let enhancers = '';

  // TODO: implement presets or something similar
  if (main.addons.includes('@storybook/addon-ondevice-actions')) {
    enhancersImport =
      'import { argsEnhancers } from "@storybook/addon-actions/dist/modern/preset/addArgs"';
    enhancers = `// temporary fix for https://github.com/storybookjs/react-native/issues/327 whilst the issue is investigated
      try {
        argsEnhancers.forEach(enhancer => addArgsEnhancer(enhancer));
      } catch{}
    `;
  }

  const fileContent = `
      /* do not change this file, it is auto generated by storybook. */

      import { configure, addDecorator, addParameters, addArgsEnhancer } from '@storybook/react-native';

      ${registerAddons}

      ${enhancersImport}

      ${previewJs}

      ${enhancers}

      const getStories=() => {
        return ${path_array_str};
      }

      configure(getStories, module, false)
  `;

  const formattedFileContent = prettier.format(fileContent, { parser: 'babel' });

  fs.writeFileSync(storybookRequiresLocation, formattedFileContent, {
    encoding: 'utf8',
    flag: 'w',
  });
}

module.exports = {
  writeRequires,
  getMain,
  getPreviewExists,
};
